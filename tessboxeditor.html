<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Image Annotator</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }

      canvas {
        background: #f0f0f0;
        cursor: crosshair;
      }

      table {
        margin-top: 10px;
      }

    .highlight {
        background-color: yellow;
        font-weight: bolder;
    }

    th, td {
        padding: 4px;
        text-align: left;
    }

    input[type="text"],
      button {
        width: 100%;
      }

    </style>
  </head>

  <body>
    <div id="root"></div>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
      const { useState, useRef, useEffect } = React;

      function ImageAnnotator() {
        const [image, setImage] = useState(
          localStorage.getItem("image") || null
        );
        const [rectangles, setRectangles] = useState(
          JSON.parse(localStorage.getItem("rectangles")) || []
        );
        const [scale, setScale] = useState(1);
        const [originX, setOriginX] = useState(0);
        const [originY, setOriginY] = useState(0);
        const [dragStart, setDragStart] = useState(null);
        const [drawing, setDrawing] = useState(false);
        const [newRect, setNewRect] = useState(null);
        const [imageLoaded, setImageLoaded] = useState(false);
        const canvasRef = useRef(null);
        const [selectedRectIndex, setSelectedRectIndex] = useState(null);
        const [focusedRectIndex, setFocusedRectIndex] = useState(null);
        const imgRef = useRef(null);

        useEffect(() => {
            const handleKeyPress = (event) => {
                console.log(`Pressed key: ${event.key}`);
                console.log(`focusedRectIndex ${focusedRectIndex}`);
                console.log(`selectedRectIndex ${selectedRectIndex}`);
            };

            window.addEventListener('keypress', handleKeyPress);

            // Cleanup function to remove the event listener when the component unmounts
            return () => {
                window.removeEventListener('keypress', handleKeyPress);
            };
        }, []); // Empty dependency array means this effect runs once on mount and cleanup on unmount


        const handleReset = () => {
            if (window.confirm('Are you sure you want to reset?')) {
                setRectangles([]);
                setImageLoaded(false);
                drawImageAndRectangles();
            }
        };

        const handleImageChange = (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              setImage(e.target.result);
              localStorage.setItem("image", e.target.result); // Store image data in localStorage
              resetView();
            };
            reader.readAsDataURL(file);
          }
        };

        const resetView = () => {
          setOriginX(0);
          setOriginY(0);
          setScale(1);
          setImageLoaded(false); // Set imageLoaded to false when a new image is loaded
        };

        // const drawImageAndRectangles = () => {
        //   const canvas = canvasRef.current;
        //   const ctx = canvas.getContext("2d");
        //   if (imageLoaded) {
        //     const img = imgRef.current;
        //     ctx.save();
        //     ctx.clearRect(0, 0, canvas.width, canvas.height);
        //     ctx.translate(originX, originY);
        //     ctx.scale(scale, scale);
        //     ctx.drawImage(img, 0, 0);
        //     rectangles.concat(newRect ? [newRect] : []).forEach((rect, index) => {
        //       ctx.strokeStyle = "red";
        //       ctx.beginPath();
        //       ctx.rect(rect.x, rect.y, rect.width, rect.height);
        //       ctx.strokeStyle = index === selectedRectIndex ? 'yellow' : 'red';
        //       ctx.stroke();
        //       ctx.fillText(rect.label, rect.x, rect.y - 10, rect.width); // Ensure text fits in the rectangle
        //     });
        //     ctx.restore();
        //   }
        // };

        const drawImageAndRectangles = () => {
            const canvas = canvasRef.current;
            const ctx = canvas.getContext("2d");
            if (imageLoaded) {
                const img = imgRef.current;
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.translate(originX, originY);
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0);

                // Draw rectangles
                rectangles.forEach((rect, index) => {
                    ctx.beginPath();
                    if (index === selectedRectIndex) {
                        // Style for selected rectangle
                        ctx.strokeStyle = 'blue';
                        ctx.fillStyle = 'rgba(0, 0, 255, 0.3)'; // 30% opaque blue
                    } else {
                        // Style for normal rectangles
                        ctx.strokeStyle = 'red';
                        ctx.fillStyle = 'transparent';
                    }
                    ctx.rect(rect.x, rect.y, rect.width, rect.height);
                    ctx.stroke();
                    ctx.fill();
                    ctx.fillText(rect.label, rect.x, rect.y - 10, rect.width); // Ensure text fits in the rectangle
                });

                // Draw newRect
                if (newRect) {
                    ctx.beginPath();
                    // Style for newRect
                    ctx.strokeStyle = 'red';
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // 30% opaque red
                    ctx.rect(newRect.x, newRect.y, newRect.width, newRect.height);
                    ctx.stroke();
                    ctx.fill();
                }

                ctx.restore();
            }
        };

        useEffect(() => {
          drawImageAndRectangles();
        }, [rectangles, originX, originY, scale, imageLoaded, newRect]);

        useEffect(() => {
          localStorage.setItem("rectangles", JSON.stringify(rectangles)); // Store rectangles in localStorage whenever they change
        }, [rectangles]);

        const handleMouseDown = (e) => {
            const rect = canvasRef.current.getBoundingClientRect();
            const x = (e.clientX - rect.left - originX) / scale;
            const y = (e.clientY - rect.top - originY) / scale;
            setDrawing(true);
            setNewRect({ x: Math.round(x), y: Math.round(y), width: 0, height: 0 });
        };

        const handleMouseMove = (e) => {
          if (drawing && newRect) {
            const rect = canvasRef.current.getBoundingClientRect();
            const moveX = (e.clientX - rect.left - originX) / scale;
            const moveY = (e.clientY - rect.top - originY) / scale;
            setNewRect({
              ...newRect,
              width: moveX - newRect.x,
              height: moveY - newRect.y,
            });
          } else {
            const rect = canvasRef.current.getBoundingClientRect();
            const x = (e.clientX - rect.left - originX) / scale;
            const y = (e.clientY - rect.top - originY) / scale;
            const index = rectangles.findIndex(rect => x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height);
            setSelectedRectIndex(index !== -1 ? index : null);
          }
        };

        const handleMouseUp = () => {
            if (drawing && newRect) {
                const updatedRectangles = [
            ...rectangles,
            {
                ...newRect,
                x: Math.round(newRect.x),
                y: Math.round(newRect.y),
                width: Math.round(newRect.width),
                height: Math.round(newRect.height)
            }
        ].filter(rect => rect.width !== 0 && rect.height !== 0);
                setRectangles(updatedRectangles);
                setDrawing(false);
                setNewRect(null);
                setSelectedRectIndex(rectangles.length);
            }
        };

        // // Truncate the rectangle coordinates to integers any time the rectangles change
        // useEffect(() => {
        //     const filteredRectangles = rectangles.filter(rect => rect.width !== 0 && rect.height !== 0);
        //     const truncatedRectangles = filteredRectangles.map(rect => ({
        //         ...rect,
        //         x: Math.round(rect.x),
        //         y: Math.round(rect.y),
        //         width: Math.round(rect.width),
        //         height: Math.round(rect.height)
        //     }));
        //     setRectangles(truncatedRectangles);
        // }, [rectangles]);

        useEffect(() => {
            const handleKeyDown = (e) => {
                if (/^[a-z0-9]$/i.test(e.key)) {
                    const updatedRectangles = [...rectangles];
                    let targetRectIndex = null;

                    if (newRect) {
                        targetRectIndex = rectangles.findIndex(rect => rect === newRect);
                    } else if (selectedRectIndex !== null) {
                        targetRectIndex = selectedRectIndex;
                    } else if (focusedRectIndex !== null) {
                        targetRectIndex = focusedRectIndex;
                    }

                    if (targetRectIndex !== null) {
                        updatedRectangles[targetRectIndex] = {
                            ...updatedRectangles[targetRectIndex],
                            label: e.key.toUpperCase(),
                        };
                        setRectangles(updatedRectangles);
                    }
                }
            };

            window.addEventListener("keydown", handleKeyDown);

            return () => {
                window.removeEventListener("keydown", handleKeyDown);
            };
        }, [newRect, selectedRectIndex, focusedRectIndex, rectangles]);

        useEffect(() => {
          const canvas = canvasRef.current;
          const handleWheel = (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - originX) / scale;
            const y = (e.clientY - rect.top - originY) / scale;
            const deltaScale = e.deltaY * -0.005;
            const newScale = Math.max(scale + deltaScale, 0.1);
            setScale(newScale);
            setOriginX(originX - x * deltaScale);
            setOriginY(originY - y * deltaScale);
          };
          canvas.addEventListener("wheel", handleWheel, { passive: false });
          return () => {
            canvas.removeEventListener("wheel", handleWheel);
          };
        }, [originX, originY, scale]);

        const updateLabel = (index, newLabel) => {
          const updatedRectangles = [...rectangles];
          updatedRectangles[index] = {
            ...updatedRectangles[index],
            label: newLabel,
          };
          setRectangles(updatedRectangles);
        };

        const handleDelete = (index) => {
            const updatedRectangles = rectangles.filter((_, i) => i !== index);
            setRectangles(updatedRectangles);
        };

        return (
          <div
            style={{
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
            }}
          >
            <div>
              <input
                type="file"
                onChange={handleImageChange}
                accept="image/*"
              />
              <button onClick={resetView}>Reset View</button>
              <button onClick={handleReset}>Reset Everything</button>
            </div>
            <canvas
              ref={canvasRef}
              width={800}
              height={600}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              style={{ border: "1px solid black", margin: "10px" }}
            />
            <img
              ref={imgRef}
              src={image}
              alt=""
              style={{ display: "none" }}
              onLoad={() => setImageLoaded(true)}
            />{" "}
            {/* Set imageLoaded to true when the image finishes loading */}
            <div>
              <h3>Annotations</h3>
              <table border="1">
                <thead>
                  <tr>
                    <th>Label</th>
                    <th>X</th>
                    <th>Y</th>
                    <th>Width</th>
                    <th>Height</th>
                  </tr>
                </thead>
                <tbody>
                  {rectangles.map((rect, index) => (
                    <tr key={index} className={index === focusedRectIndex ? 'highlight' : ''}>
                        <td>{rect.label}</td>
                        <td>{rect.x}</td>
                        <td>{rect.y}</td>
                        <td>{rect.width}</td>
                        <td>{rect.height}</td>
                        <td><button onClick={() => handleDelete(index)}>Delete</button></td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        );
      }

      ReactDOM.render(<ImageAnnotator />, document.getElementById("root"));
    </script>
  </body>
</html>
